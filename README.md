# blockChainVoting
Voting on machines running blockchains. Blockchain verification is such that block is only accepted if 90%(GLOBAL VARIABLE) of the blocks are all the same, and a changed block would be rewritten.
Three priority rankings can be selected(or not?)
  
DOCUMENTATION
1. Everytime user enters a vote, it is appended to a file(initially empty) in the user's machine, and send to all other machines on the network. this same vote(entry) is also appended to other other computers, and so on. when one machine reaches the 500 limit of a block, it sends a signal to all computers to pause for a lil bit(required or not?), and sort the block according to alphabet. Compare all blocks(the file), and if they are equal(more than 90%), add it to the blockchain(initially empty) on every computer; replace the rigged ones with the good blocks, and add them to the chain as well. if more than 10% are unequal, disregard the block and throw it away, printing out an exception that 500 votes were discarded because the block was rigged on X percentage of computers. Clear the block data, and restart. Once all the voting is done (select so on every machine on the blockchain), compare the entire blockchain and if it's equal(more than 90%), display the results, and if not display that requirements for a secure non rigged system weren't passed, and X percentage of the systems had different votes than expected. Display the rigged result regardless.
2. Every entry/vote of an user will have three candidate priorities. First priority will be multiplied by 3, second by 2 and third by 1. Hence, candidate with maximum points wins. Points will not indicate number of votes, though, and a separate thing should display results for the number of votes counter. Voter ID can be used to determine the location of vote later on. 
3. Depending upon the end user, the two values can be used to determine the winner.

There can be three main parts to the program - 
1.  user enters voting id number(unless the card is scannable) and candidate number(or clicks on their picture/whatever). then {<voting id number>, <priority>} is the asset of candidate number {<candidate number>}. This is written to a block of 500(GLOBAL VARIABLE) entries. figure out how to accomodate votes coming in from different machines together. [UI]
2.  take all blocks and parse file to calculate the total votes(every 30 min?). if a block doesn't agree with the same block from other machines (90%, global var), replace all the blocks from machines with different blocks. if more than 10% of the machines return a different block, quit and say that the vote was rigged.[FULLY gBACKEND]
3.  Network. Access the harddrive(where the blocks are stored) on every computer, how to use the same block/file from every machine on the network to compare them. How to constantly send and recieve data between the machine and the application running on it. [NETWORK]
